/**
 * ARCHIVE-35 Secure Original Image Server
 * Cloudflare Pages Function
 *
 * GET /api/serve-original?key={collection/filename.jpg}&sig={hmac}&exp={timestamp}
 *
 * Serves high-res originals from R2 storage with HMAC-signed URLs.
 * Only valid signed URLs (generated by the webhook) can access originals.
 * This prevents unauthorized access to paid fine art originals.
 *
 * Required:
 *   R2 Binding: ORIGINALS (bound to archive-35-originals bucket)
 *   Env var: ORIGINAL_SIGNING_SECRET (shared secret for HMAC signatures)
 */

// ============================================================================
// HMAC SIGNATURE VERIFICATION
// ============================================================================

async function verifySignature(key, expiry, signature, secret) {
  if (!secret || !signature || !expiry || !key) return false;

  // Check expiry
  const expiryTime = parseInt(expiry);
  if (isNaN(expiryTime) || Date.now() > expiryTime) {
    return false; // Expired
  }

  // Verify HMAC
  const message = `${key}:${expiry}`;
  const encoder = new TextEncoder();
  const cryptoKey = await crypto.subtle.importKey(
    'raw',
    encoder.encode(secret),
    { name: 'HMAC', hash: 'SHA-256' },
    false,
    ['sign']
  );
  const sig = await crypto.subtle.sign('HMAC', cryptoKey, encoder.encode(message));
  const expected = Array.from(new Uint8Array(sig))
    .map(b => b.toString(16).padStart(2, '0'))
    .join('');

  return expected === signature;
}

// ============================================================================
// GENERATE SIGNED URL (exported for use by webhook)
// ============================================================================

export async function generateSignedUrl(key, secret, expiryMs = 24 * 60 * 60 * 1000) {
  const expiry = String(Date.now() + expiryMs);
  const message = `${key}:${expiry}`;
  const encoder = new TextEncoder();
  const cryptoKey = await crypto.subtle.importKey(
    'raw',
    encoder.encode(secret),
    { name: 'HMAC', hash: 'SHA-256' },
    false,
    ['sign']
  );
  const sig = await crypto.subtle.sign('HMAC', cryptoKey, encoder.encode(message));
  const signature = Array.from(new Uint8Array(sig))
    .map(b => b.toString(16).padStart(2, '0'))
    .join('');

  return {
    url: `/api/serve-original?key=${encodeURIComponent(key)}&exp=${expiry}&sig=${signature}`,
    fullUrl: `https://archive-35.com/api/serve-original?key=${encodeURIComponent(key)}&exp=${expiry}&sig=${signature}`,
    expiry,
    signature,
  };
}

// ============================================================================
// REQUEST HANDLER
// ============================================================================

export async function onRequestGet(context) {
  const { request, env } = context;
  const url = new URL(request.url);

  const key = url.searchParams.get('key');
  const sig = url.searchParams.get('sig');
  const exp = url.searchParams.get('exp');

  const SIGNING_SECRET = env.ORIGINAL_SIGNING_SECRET || '';
  const R2_BUCKET = env.ORIGINALS; // R2 binding

  // Validate params
  if (!key || !sig || !exp) {
    return new Response(JSON.stringify({ error: 'Missing parameters' }), {
      status: 400,
      headers: { 'Content-Type': 'application/json' },
    });
  }

  // Verify signature
  if (SIGNING_SECRET) {
    const valid = await verifySignature(key, exp, sig, SIGNING_SECRET);
    if (!valid) {
      return new Response(JSON.stringify({ error: 'Invalid or expired signature' }), {
        status: 403,
        headers: { 'Content-Type': 'application/json' },
      });
    }
  }

  // Check R2 binding
  if (!R2_BUCKET) {
    console.error('ORIGINALS R2 binding not configured');
    return new Response(JSON.stringify({ error: 'Storage not configured' }), {
      status: 500,
      headers: { 'Content-Type': 'application/json' },
    });
  }

  // Fetch from R2
  try {
    const object = await R2_BUCKET.get(key);
    if (!object) {
      return new Response(JSON.stringify({ error: 'Original not found', key }), {
        status: 404,
        headers: { 'Content-Type': 'application/json' },
      });
    }

    // Stream the original to the client
    const headers = new Headers();
    headers.set('Content-Type', object.httpMetadata?.contentType || 'image/jpeg');
    headers.set('Content-Length', String(object.size));
    headers.set('Cache-Control', 'private, no-store'); // Don't cache originals publicly
    headers.set('Content-Disposition', `attachment; filename="${key.split('/').pop()}"`);
    // CORS: Allow Pictorem (and other print fulfillment partners) to fetch originals
    headers.set('Access-Control-Allow-Origin', '*');

    return new Response(object.body, { headers });

  } catch (err) {
    console.error('R2 fetch error:', err.message);
    return new Response(JSON.stringify({ error: 'Storage error', details: err.message }), {
      status: 500,
      headers: { 'Content-Type': 'application/json' },
    });
  }
}
